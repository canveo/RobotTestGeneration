# Dev documents
https://forum.developer.parrot.com/t/using-bebop-autonomy-with-sphinx-on-same-machine/6726/11

# A file containing documents of another group which did something similar to this
https://mrsdprojects.ri.cmu.edu/2017teamf/wp-content/uploads/sites/27/2017/10/TeamF_danendrs_ILR04.pdf

# Notes on how to upload the parrot mavlink files
https://forum.developer.parrot.com/t/parrot-sphinx-make-drone-follow-fixed-trajectories/9031
https://forum.developer.parrot.com/t/flightplans-and-sphinx/7785/4

# It seems that there is another version I can compile and use that to run GPS waypoints
https://ardrone-autonomy.readthedocs.io/en/gps-waypoint/gps.html

# Someone who couldnt figure out mission planner file formats
https://forum.developer.parrot.com/t/what-flight-plan-format-mavlink-and-waypoint/7387

# Explaining the file format
https://diydrones.com/forum/topics/waypoint-file-format
https://mavlink.io/en/messages/common.html#MAV_CMD_NAV_WAYPOINT

# My Question
https://forum.developer.parrot.com/t/exporting-flight-plans-from-freeflight-pro-for-use-in-sphinx/9466/2
https://forum.developer.parrot.com/t/what-flight-plan-format-mavlink-and-waypoint/7387/6


You need to install the bebop driver as follows:
$ sudo apt-get install build-essential python-rosdep python-catkin-tools
$ cd ros_ws/
$ rosdep update
$ rosdep install --from-paths src -i


If you want to connect to the drone you can use the:
http://localhost:9002

I modified the file

/opt/parrot-sphinx/usr/share/sphinx/drones/bebop2.drone

How to start drone:
Open the firmware
$ sudo systemctl start firmwared.service

Check the firmware is running
$ fdc ping

If you get this error:
[Err] [Machine.cc:1201] Preparation of firmware for machine follower failed: curl.hook/probe failed.. Check your path or URL to the firmware]

You can run the command:
$ fdc drop_all firmwares

You can view the images taken by the drone using: 
$ rosrun image_view image_view image:=/bebop/image_raw

We can get the drone to perform flips using:
$ rostopic pub --once bebop/flip std_msgs/UInt8 '{data: 0}'

Scripts are for simulating things happening externally to the drone, e.g. being thrown. We need to create a waypoint file and then upload it to the drone.

To manually move the drone around you can use the commands
rostopic pub -r 10 bebop/cmd_vel geometry_msgs/Twist  '{linear:  {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}'

We can upload our files to the drone after the drone has been launched using:
$ curl -T test.mavlink ftp://10.202.0.1:61/

I believe this uploads the file to the following directory on the drone
/data/ftp/internal_000/flightplans

# Standard Approach
0) Launch the drone firmware
$ sudo systemctl start firmwared.service

1) Launch the simulator
$ sphinx /home/autosoftlab/Desktop/RobotTestGeneration/ParotSimulation/sphinxfiles/worlds/outdoor_1.world /home/autosoftlab/Desktop/RobotTestGeneration/ParotSimulation/sphinxfiles/drones/bebop2_local.drone::with_front_cam=true

2) Launch the driver
$ source devel/setup.zsh
$ roslaunch bebop_driver bebop_node.launch ip:="10.202.0.1"

3a) Upload the waypoints
$ curl -T test.mavlink ftp://10.202.0.1:61/

4) Start following waypoints
$ rostopic pub --once bebop/autoflight/start std_msgs/String '{data: test.mavlink}'

3b) Launch the joy controller we have created
$ source devel/setup.zsh
$ rosrun joy joy_node
$ rosrun bebop_utils joy_to_bebop.py

**Note:** A command from the controller will stop the drone from following a flight plan!

# Right now if I upload a file and it finds it it will take off and then not do anything.
Two possiblilites. Maybe it goes through the sequence of waypoints too quickly. So I will do a test where I make the number of waypoints much longer. The second possibility is that for some reason after finding the first file it defaults to the normal file name "flightplan"


The mavros file format is as follows:

A waypoint file is described as follows in the mavlink docs (https://mavlink.io/en/file_formats/#mission_plain_text_file):

QGC WPL <VERSION> 
<INDEX> <CURRENT WP> <COORD FRAME> <COMMAND> <PARAM1> <PARAM2> <PARAM3> <PARAM4> <PARAM5> <PARAM6> <PARAM7> <AUTOCONTINUE>

Note: They list param5 as longitude and param6 as latitude (this is where the confusion stemmed from)

We are sending waypoints ie <COMMAND>=16. You can find the defintion of this command on the mavlink github page (https://github.com/mavlink/mavlink/blob/master/message_definitions/v1.0/common.xml#L774) (see below) as well as on the Ardupilot documentation (http://ardupilot.org/copter/docs/common-mavlink-mission-command-messages-mav_cmd.html#mav-cmd-nav-waypoint). 

<enum name="MAV_CMD">
      <description>Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data. See https://mavlink.io/en/guide/xml_schema.html#MAV_CMD for information about the structure of the MAV_CMD entries</description>
      <entry value="16" name="MAV_CMD_NAV_WAYPOINT" hasLocation="true" isDestination="true">
        <description>Navigate to waypoint.</description>
        <param index="1" label="Hold" units="s" minValue="0">Hold time. (ignored by fixed wing, time to stay at waypoint for rotary wing)</param>
        <param index="2" label="Accept Radius" units="m" minValue="0">Acceptance radius (if the sphere with this radius is hit, the waypoint counts as reached)</param>
        <param index="3" label="Pass Radius" units="m">0 to pass through the WP, if &gt; 0 radius to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control.</param>
        <param index="4" label="Yaw" units="deg">Desired yaw angle at waypoint (rotary wing). NaN for unchanged.</param>
        <param index="5">Latitude</param>
        <param index="6">Longitude</param>
        <param index="7">Altitude</param>
       </entry>
       ...

Documentation for mavlink also confirms this (https://mavlink.io/en/messages/common.html#MAV_CMD_NAV_WAYPOINT). This states that param5 is latitude and param6 longitude.



To do this in the cage do the following:

First start by turning the parrot drone on. The parrot drone will create a wifi hotspot which you can then connect to.

To connect we can use the ethernet wifi cards we have bought.

We need to assign static IP to the ether port. To do this run:

$ ifconfig
>>> It should be an enp1p* connection

Now assign the IP address:

$ sudo ifconfig enp1p1 192.168.1.2

Then launch the internet browser and connect to "192.168.1.252"



Next launch the ROS code using

2) Launch the driver
$ roslaunch bebop_driver bebop_node.launch ip:="192.168.42.1"

Check that it is working using:

You can view the images taken by the drone using: 
$ rosrun image_view image_view image:=/bebop/image_raw

You can then control the drone by running:
$ source devel/setup.zsh
$ rosrun joy joy_node
$ rosrun bebop_utils joy_to_bebop.py

You can upload waypoint files using:
$ curl -T flightplan.mavlink ftp://192.168.42.1:61

You can then follow the waypoint files as:
$ rostopic pub --once bebop/autoflight/start std_msgs/String '{data: test.mavlink}'

You can get the current GPS co-ordinates using:
$ rostopic echo /bebop/states/ardrone3/PilotingState/PositionChanged

**note:** if they latitude and longitude are 500, that means it does not have a gps lock




Top TIP: To restart your network manager after running one of the simulations use:
$ sudo service network-manager restart



This simulator connects to the network interface. When we close the simulator it does not reset the network interface name to the orignal name. In order to do this we have added a set of rules in the udev folder as follows:
```
$ cd /etc/udev/rules.d
# Possibly didnt need this one
$ sudo nano 76-netnames.rules
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="e0:d5:5e:25:d4:6a", NAME="enp0"
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="00:1b:21:a7:54:0c", NAME="enp1p0"
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="00:1b:21:a7:54:0d", NAME="enp1p1"
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="00:1b:21:a7:54:0e", NAME="enp1p2"
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="00:1b:21:a7:54:0f", NAME="enp1p3"

$ sudo nano 70-persistent-net.rules
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="e0:d5:5e:25:d4:6a", NAME="enp0"
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="00:1b:21:a7:54:0c", NAME="enp1p0"
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="00:1b:21:a7:54:0d", NAME="enp1p1"
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="00:1b:21:a7:54:0e", NAME="enp1p2"
>>> SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="00:1b:21:a7:54:0f", NAME="enp1p3"
```

Now the network interface names will stay the same. However after each simulation you need to deactive and reactivate the network card. You can do this using:
```
$ ifconfig <wrong_name> down  
$ ip link set <wrong_name> name <correct_name>  
$ ifconfig <correct_name>   up 
```

So for example
```
$ ifconfig dev6 down  
$ ip link set dev6 name enp0  
$ ifconfig enp0 up 
```

We can get the <wrong_name> using:
```
$ wrongname=`ifconfig | grep e0:d5:5e:25:d4:6a | awk '{print $1}'`
```